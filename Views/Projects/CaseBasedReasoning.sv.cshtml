<div class="project">
    <h1>En Case-Based Reasoning Approach till en Schack AI Baserad på Grundlig Likhet</h1>
    
    <div class="project-abstract">
        <h2>Sammanfattning</h2>
        <img src="@Url.Content("~/img/Case Based Reasoning Image.jpg")"/>
        <p>
            Schack är ett spel som ofta används för att undersöka olika tekniker inom AI.
            I denna rapport ställs följande fråga:
            <strong>Är det möjligt att utveckla en AI-agent vars beslutsfattade är baserat på tekniken "Case-based Reasoning" (CBR) som använder grundlig likhet och spelar bättre med
            hjälp av fallbaser baserade på bättre spelare?</strong>
            En <strong>AI-agent har utvecklats som har spelat ett antal matchar emot sig själv</strong> med hjälp av olika fallbaser baserade på olika spelare.
            Efter att ha undersökt resultatet, visade det sig att <strong>Ai-agenten spelar så dåligt att den nästan aldrig lyckas vinna</strong> oavsett fallbas,
            vilket innebär att <strong>det inte var möjligt att gradera dem baserat på skicklighet</strong>.
            Det kan fortfarande vara användbart att undersöka om en CBR-baserad schackspelande AI-agent skulle kunna spela schack på hög skicklighetsnivå.
        </p>
        <p>
            Hela rapporten kan laddas ner på <a href="http://urn.kb.se/resolve?urn=urn:nbn:se:his:diva-11049">Diva</a>
        </p>
    </div>

    <div class="project-summary">
        <div class="project-summary-language">Språk: C#</div>
        <div class="project-summary-period">År: 2015</div>
        <div class="project-summary-group">Institution: HiS</div>
    </div>

    <h2>Programmingserfarenhet</h2>
    <p>
        Detta projekt var väldigt intressant att arbeta med, eftersom det gav mig en chans att programmera mer funktionellt än jag tidigare hade gjort.
        <strong>Klasser gjordes immuterbara,</strong> och deras publika gränssnitt begränsades till det ytterst nödvändigaste, <strong>vilket gjorde det svårare att skriva kod full med buggar</strong>.
        <strong>I stort sätt all schackrelaterad kod enhetstestades</strong>, och jag körde inte programmet förrän alla testerna gav positivt resultat.
    </p>
    <p>
        Allt fungerade bra i början av projektet, men snart möttes jag av <strong>prestanda problem</strong>, i största del relaterat till onödiga allokationer av listor och bräden.
        För att fixa problemet så <strong>ändrade jag representationen och implementationen av några klasser utan att ändra deras publika gränssnitt</strong>.
        Detta tillät mig att testa de ändringar jag gjort, för att garantera att jag inte introducerat någon bugg.
    </p>
    <p>
        Så, i slutändan <strong>introducerade jag mutabilitet</strong> för att läsa problemet.
        Trots det så betyder det inte att det var värdelöst att programmera funktionellt från början.

        <ul>
            <li>Immutabiliteten ledde till att klassernas gränsnitt minskade, <strong>vilket snabbade upp den initiella test processen</strong>.</li>
            <li>Trots att den ursprungliga implementationen och representationerna behövde ändras något, så gick det snabbt och enkelt att utveckla dem, och <strong>ledde till klarare kod</strong>.</li>
            <li>
                Eftersom det inte fanns någon delad state i programmet som muterades så så var det <strong>enkelt att skala programmet</strong> för att simulera flera schack matcher paralellt med PLINQ.
            </li>
        </ul>
        Denna upplevelse har lett mig till att <strong>utveckla mer funktionellt</strong> och skriva mer enhetstester.
        Tyvärr så är fördelarna inte alltid värt det på små projekt där kraven ändras konstant.
        Det är viktigt att vara pragmatisk och använda rätt verktyg för rätt jobb.
    </p>
</div>

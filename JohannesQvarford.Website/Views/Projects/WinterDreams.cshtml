<div class="project">
    <h1>Winter Dreams</h1>
    <img class="project-image" src="~/Content/Images/WinterDreamsBig.jpg" />
    <div class="project-summary">
        <div class="project-summary-language">Language: C++</div>
        <div class="project-summary-period">Year: 2013</div>
        <div class="project-summary-group">Institution: HiS</div>
    </div>


    <h2>Introduction</h2>
    <p>
        Winter Dreams is a game about a winter princess that gets trapped in her dreams, and has to escape by solving puzzles.
        The game uses an isomorphic camera, and includes features such as
        <strong>
            voiced dialogue with subtitles, cutscenes, shader lighting, dynamic footprints and ukontrøll support.
        </strong>
        It supports 
        <strong>
            dynamic loading of levels, settings and entity type properties without
            recompilation.
        </strong>
    <p>
    <p>
        A demo of the game was completed in June 2013, and the source code for the demo can be found <a href="https://github.com/johannes-qvarford/Winter-Dreams">here</a>.
        A trailer for the demo was also released <a href="https://www.youtube.com/watch?v=A5969PjI02I&feature=youtu.be">here</a>.
    </p>
    <p>
        This was my first big collaborative project at the University of Skövde, and also my first major role as a <strong>lead programmer</strong>.
        It was my responsibility to organize the other programmers, communicate between us and the other leads, as well
        as programming a large part of the game.
    </p>


    <h2>As a Programmer</h2>
    <h3>Dynamic Configuration</h3>
    <p>
        I was in charge of the <strong>level loading system</strong>, which was eventually expanded for loading settings and entity type properties.
        We used <strong>Tiled</strong> to design levels, because it was the first best editor we could find that supported isomorphic 2D levels.
        Tiled levels could be exported to <strong>JSON</strong>, so my first task was to use a library to parse the <strong>JSON</strong>, create the entities and tiles,
        and finally run the game.
    </p>
    <p>
        The game had many different entity types, so in order to handle the complexity of parsing the levels,
        I created the so called <strong>Entity Registration System (ERS)</strong>. The ERS tied every entity type to a name, and
        a function for converting a serialized entity to an in-memory entity. When a serialized entity was found, its name was used to
        lookup the correct conversion function and create the entity. So called <strong>Entity Registrations</strong> were used to register the entity type
        at startup. By declaring a global Entity Registration with a name and function, the entity was registred as soon as the game started.
        It's debateable if using global variables like this was a good idea; it sped up compilation time, as there was no need for a big
        registration function that grew every time a new entity type was added, but at the same time it made the control flow less intuitive.
    </p>
    <p>
        Compilation took a very long time on our school computers, and changing a single entity property's default value could result in a tripple digit compilation time
        <strong>To speed up development, entity property default values and general settings were moved out of the source files, and into configuration files</strong> that
        were loaded when the game started. We still had to reload the game, which started to take longer and longer towards the end of the project,
        so it might've been fitting to continuously check for changes in the configuration files, and reload them as necessary during runtime.
    </p>
    <p>
        In order to make it easier for designers to control gameplay flow, I implemented the <strong>Trigger Activation System (TAV)</strong>. The TAV
        tied every entity to a state, active or not and allowed them to be triggered. Different entities got triggered in different ways
        and behaved differently when they were activate or not, which was implemented by us programmers. However, <strong>how the entities reacted when they
        got triggered could be decided by the designers.</strong> For instance, we could program a trigger area that got triggered when its area
        collided with the player, and we could also program an entity whose only goal is play some dialogue when it was activated.
        The designers could then create different areas that activated different pieces of dialogue when each area got triggered.
    </p>
    <p>
        I handled some smaller tasks as well, like <strong>implementing lights</strong>. The levels were dark, but contained several light sources scattered
        across the level, and one surrounding the player. The radius and brightness of the light surround the player increased as
        the player healed themselves and decreased as they took damage. The effect was implemented by using a <strong>pixelation shader</strong>,
        and darkening pixels based on their distances to the light sources.
    </p>

    <h2>As a Lead</h2>
    <p>
        I had been programming in high school, so at this point I had much more programming experience than the others.
        As such, I felt that I had to teach the team how best to structure the code, documentation and handle version control.
        It was tough to be doing <strong>everything at once</strong>, but I felt that I was best suited for all of the responsibilities. Maybe in a bigger project
        I would feel the need to delegate the responsibility to avoid getting stressed out, but for this project it worked fine.
        I was also lucky to have a <strong>talented programmer by my side</strong> who helped me brainstorm ideas and implement some of the more
        more advanced parts of the game.
    </p>

    <p>
        I <strong>failed as a leader</strong> when it came to dealing with one of the other programmers. The other programmer had concentration issues and
        would disregard agreed upon task assignments and coding standards, which among other things caused me and the rest of the programmers
        to grow hostile towards him. I didn't want to deal with him, so I gave him a big task hoping that it would keep him preoccupied
        and out of my hair for a long time. However, due to my lack of leadership, <strong>I didn't push him hard enough to perform the task,</strong>
        and it was delayed several weeks. I shouldn't have let my personal issues with the programmer risk the completion of the project.
    </p>

    <p>
        Another programmer who was difficult for me to deal with had a different problem. <strong>He wasn't very good or enthusiastic about programming</strong>
        and even stated outright that he would be switching his major the next semester. I tried to give him some simple tasks to perform
        but it usually resulted in me showing him how to do most of the work. I don't blame him for not wanting to program, but it put me
        in a difficult spot in deciding <strong>how he could contribute to the project</strong>. I could've given him even simpler tasks to perform, but
        these would have to be artificially created, not out of need for the project and still take time to think of.
        This would've at least have given him something to show to the teachers so he wouldn't have failed the course.
        I could've also shown him how to do his assigned tasks, but this would've kept me occupied while I had my own things to do.
        I could also have given him no tasks to perform, but this would've certainly made him fail the course, and I <strong>didn't want him to feel useless</strong>.
    </p>
    <p> In the end, I gave him tasks, and showed him how to do those that he thought were too hard.
        I still don't know the best way to handle the situation, to slow down the project or risk hurting his feelings.
        <strong>I should've maybe talked with him and the teachers</strong> to get more input for what they felt was best, and based my decision on that.
        It's also very different to make this decision in a school project, as opposed to a corporate one.
        <strong>
            In a corporate project I would have fired him
        </strong>
        for not contributing enough, but creating a good game at a low cost wasn't the main goal of the school project.
    </p>

</div>